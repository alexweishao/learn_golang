深入理解计算机系统
第一章计算机系统漫游
本章通过跟踪hello程序的生命周期对系统进行学习。从程序创建-->运行-->输出-->终止，沿着整个程序的生命周期，逐步介绍有关概念，术语和组成。

## 1.1 信息就是位+上下文

源程序实际上是由值0和1组成的位（比特）序列，8个位被组织成一个组，称为字节。
大部分计算机系统都是用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值印来表示每个字符。
hello.c程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。
hello.c的表示方法说明了一个基本思想:系统中所有的信息--包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。

## 1.2程序被其他程序翻译成不同的格式

为了让程序最终在操作系统上运行，实际上就是设置一个人和计算机沟通的过程。人类可以理解的就是十进制，计算机可以理解的就是二进制，也就是0和1，所以为了让程序可以运行，就需要经过把数字转变为计算机可以识别的二进制。
编译系统:
预处理阶段:预处理器(cpp)根据以字符#开头的命令，修改原始的C程序，生成hello.i的文本文件。
编译阶段:编译器(ccl)将文本文件hello.i翻译成文本文件hello.o，它包含一个汇编语言程序。该程序包含函数main的定义，如下所示
汇编阶段:接下来，汇编器(as)将hello.c翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序的格式，并将结果存放在目标文件hello.o中。该文件是一个二进制文件。
链接阶段:由于hello程序调用了printf函数，而该函数是一个标准C库中的函数，存在于一个名为printf.o的单独的预编译好的目标文件中，该过程就是把这个文件合并到hello.o中。结果就得到hello文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。

## 1.3 了解编译系统如何工作是大有益处的

通过编译系统可以将hello.c程序生成正确有成效的机器代码。
编译系统如何工作：
优化程序性能
理解连接时出现的错误
避免安全漏洞

## 1.4 处理器读并解释储存在内存中的指令

编译系统将hello.c源程序被翻译成可执行目标文件hello，并被存放在磁盘上。要想在 Unix系统上运行该可执行文件，我们将它的文件名输入到称为shell的应用程序中∶
linux> ./hello
hello.world
linux>

shell是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。
hello程序运行时发生了什么，需要通过计算机典型系统硬件组织来解读
系统的硬件组成：
总线-->携带信息字节并负责在各个部件间传递

I/O设备 -->
I/O(输入/输出)设备是系统与外部世界的联系通道。我们的示例系统包括四个I/O设备:作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器(磁盘)。最开始，可执行程序hello就存放在磁盘上。

主存-->主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

处理器：
中央处理单元(CPU)，简称处理器，是执行存储在主存中指令的引擎。处理器组成如下:
- PC:程序计数器，大小为一个字节的存储设备，在任何时刻，PC都指向主存中的某条机器语言指令
- 寄存器文件:是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字
- ALU:算术/逻辑单元，计算新的数据和地址值。
  下面是一些简单操作的例子:

- 加载∶ 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。
- 存储∶ 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
- 操作∶把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。
- 跳转∶从指令本身中抽取一个字，并将这个字复制到程序计数器(PC)中，以覆盖 PC中原来的值。
  运行程序的过程----------->>>>>>>>>>


## 1.5 高速缓存至关重要

当程序加载时，它们被复制到主存;当处理器运行程序时，指令又从主存复制到处理器。这些复制就是开销，减慢了程序"真正"的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。

根据机械设备原理，较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。比如说，从磁盘读取一个字节的时间开销要比从主存中读取的开销大1000万倍；处理器从寄存器文件读数据比从主存中读取几乎要快100万倍。
针对这种处理器与主存之间的差异，系统设计者设计出了高速缓存，作为暂时的集结区域。
主要包括:
- L1高速缓存:容量可以达到数万字节，位于处理器芯片上，访问速度几乎和访问寄存器文件一样
- L2高速缓存:容量为数十万到数百万字节，通过一条特殊的总线连接到处理器，进程访问L2高速缓存的时间是L1的5倍
- L3高速缓存:最低级别的缓存，所有内核之间共享
  本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。

## 1.6 存储设备层次结构

每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价越来越便宜。寄存器文件在层次结构中处于最顶部。

## 1.7 OS管理硬件

操作系统有两个基本功能:
- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备

##   1.8进程

  进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以运行多个进程，而每个进程都好像在独占地使用硬件。并发运行是指，一个进程的指令和另一个进程的指令是交错执行的。在大多数系统中，需要运行的进程数是多余可以运行它们的CPU个数的。先进的多核处理器同时能够执行多个程序。操作系统实现这种交错执行的机制称为上下文切换。
  在只讨论一个CPU的单核处理器系统的情况。
  操作系统保持跟踪进程所需的所有状态信息，这种状态，称为上下文。包括许多信息，比如PC和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单核CPU只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换。
  线程
  在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。
  虚拟内存
  虚拟内存是一个抽象概念，它为每个进程提供了一种假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。
  文件
  文件就是字节序列。每个I/O设备,包括磁盘、键盘、显示器甚至网络，都可以看成是文件。

##   1.9重要主题

  系统不仅仅只是硬件，是硬件和系统软件互相交织的集合体。
  Amdahl定律：
  要想显著加速整个系统，必须提升全系统中相当大的部分的速度。
  并发和并行
  我们需要计算机做得更多，计算的更快，，因此需要大力改进处理器，当处理器能够同时做更多的事情时，这两个因素都会改进。
  计算机系统中抽象的重要性
  文件是对I/O设备的抽象、虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象，虚拟机提供对整个计算机的抽象。

第二章 信息的表示和处理
## 2.1信息储存
1.大多数计算机使用8位的块（称为字节(byte)），作为最小的可寻址的内存单位，而不是去访问单独的一个位。
2.机器级程序将计算机的内存看做是一个很大的字节数组，称作虚拟内存。虚拟内存的每个字节都由唯一的数字来标识，称它为地址
3.一个字节有8位，即用二进制表示会有八位数，这样表示会比较冗长，所以使用最多的还是十六进制数（如0xA9）,一个位十六进制数就可以表示一个8位的二进制数。同理，一个字节可以由两个十六进制数表示。
4.十进制，二进制，十六进制转换图
5.每台计算机都有字长（32位或64位，这里的概念注意跟字节区分），指明指针数据的标称大小。
6.因为虚拟地址是一个字长来表示的，所以字长的大小决定了虚拟地址的寻址大小
7.在编译的时候就会决定一个程序是32位程序还是64位程序
8.C语言中的char型就表示一个单独的字节，尽管它是用来保存单个字符而得名。
- 在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址就是字节序列中最小的地址。
- 最低有效字节在最前面的方式称为 小端法(little endian)
- 最高有效字节在最前面的方式成为 大端法(big endian)
- Android 和 IOS都是只能运行小端法
- 尤其注意的是不同类型的机器通过网络传输二进制数据的时候，会发现字节序列是反序的
- 阅读整数数据的字节序列时，字节的顺序也很重要。
- 在编程中，取对象的字节表示时，字节顺序也很重要。
- 字符串中的每个字符都是以某个标准编码来表示，最常见的就是ASCII码。（可以使用命令man ascii 来生成一张ASCII字符编码表）
- 从计算机的角度来看，一个程序仅仅是一个字节序列。除了可能用来帮助调试的表以外，机器没有关于原始源程序的任何信息。
- 逻辑值（真）和逻辑值（假）分别对应二进制编码1和0
  逻辑运算中，将所有非零的参数都表示TRUE，参数0表示为FASLE，它们返回1或者0,分别表示结果为TRUE或FALSE
- 位移运算是一种按位操作的模式，比如左移（即 x<<k， x变量向左移动k位），就是将x的最高k位舍弃，并在低位补k个0。
- 右移比较特殊（x>>k），分为两种情形：算术右移和逻辑右移。
- 逻辑右移：在左端补k个0。
- 算术右移：在左端补k个最高有效位。
- C语言中并没有明确表示对有符号的右移使用哪种右移，但是对于几乎所有的编译器来说，对有符号使用算术右移，对于无符号来说右移都是逻辑右移。
  ## 2.2整数表示
- 整数表示分为两种：一种是非负数表示，即0和正数的表示。另一种是能表示负数、零和正数
  有符号的数据类型，取值不是对称的，负数范围取值比正数取值范围大1。（与负数的编码有关）
- 计算机表示负数的形式是通过补码（two’s-complement）形式来表示。
- 补码就是将最高有效位解释为负权（negative weight）。
  补码表示的最小值是最高位为1，其他位为零的情况。
  补码表示的最大值是最高位为0，其他位都为1的情况（从这里就可以看到有符号类型的表示范围不是对称的原因，一半的范围用来表示非负数，另一半用来表示了负数）。
  补码的表示也是一一对应的关系，即一个二进制数可以唯一的转换为一个整数，反之也是唯一对应的。
  当一个数的位模式最高位为0时，无符号数和有符号数（补码）之间转换，数值不会改变，如果最高位为1时，那么在表示无符号数时，最高位就是实实在在的权值，而表示有符号时，最高位就是符号位，表示负数。
  C语言支持无符号与有符号，默认状态下C语言声明的整数都是有符号数，如果要声明无符号数需要在数字后面加U或u 或者是用关键字unsigned声明。
  C语言中的有符号数都是用补码表示
  无符号与有符号之间的转换，主要遵守的原则就是底层的位表示不会变。
  由于C语言中是同时包含无符号与有符号数，当执行一个运算就需要尤其注意，当一个运算数是无符号，另外一个是有符号数时，Ｃ语言会隐式的将有符号数转换为无符号数，并且都将他们看作非负数处理。特别是在做大小判断的时候尤其需要注意。
  ## 2.4浮点数
- 因为表示浮点的方法限制了浮点表示的范围和精度，所以浮点数只能近似的表示实数运算。
- IEEE浮点格式定义了四种不同的舍入方式：向偶数舍入，向零舍入，向下舍入，向上舍入：
- 向偶数舍入：也称为向最接近的值舍入，但是当值处于中间的请求，那么他会向舍入结果最低有效位是偶数的方向舍入，所以举例来说1.5或者2.5，通过向偶数舍入的结果都是2。而1.4的舍入结果就是1。
- 向偶数舍入一般会是用在避免统计偏差的情况，如果总是使用向上舍入或者向下舍入，在统计数据时数据的误差就会因为舍入的原因，不断加大（数据越多，误差就会越大），向偶数舍入在大多数情况下可以避免这种情况，50%的时间它是向上舍入，50%的时间是向下舍入。
- C语言将信息编码为bits（比特），通常组织成为字节序列，一个字节8位，有不同的编码方式用来表示整数，实数或字符串。
- C语言对有符号使用补码表示，对小数使用浮点数表示。深刻的理解他们的位级编码方式，对正确编程特别是正确的数值运算有很大帮助。
- 浮点数由于他很特别的编码方式，运算的结合律对于浮点数来说都是不适用的，这一点尤为需要注意。