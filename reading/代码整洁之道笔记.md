## 1.命名

- 名副其实：命名要做到看其名知其意。选择体现本意的名称能让人更容易理解和修改代码。
- 避免误导：避免使用与本意相悖的词，避免使用有歧义的词以及相似的词。
- 使用有意义的命名：a,b,c。a1,a2,a3等均属于无意的词汇。命名要明确用意。
- 使用易读的名称：（正常人在项目中不会出现）
- 使用可搜索的名称：名称长短应与其作用域大小相对应。
- 避免使用编码命名：自找麻烦，增加代码负担，带编码的名称通常发音不便，易打错。
- 类名：类名和对象名应该是名词或者名词短语Customer，AddressParser，不应当是动词。
- 方法名：方法名应当是动词或者动词短语，postPayment/save。
- 一个概念对应一个词：函数名应当独一无二，且要保持一致。
- 使用领域相关的词：只有程序员会读你的代码，尽管使用计算机科学（Computer Science，CS）术语，算法名，模式名，数学术语。

##   2.函数

- 短小：函数的第一规则是要短小。第二规则是更短小。
- 只做一件事：函数应该做一件事。做好这件事。只做这一件事。判断函数是否只做一件事，可以看是否能将目标函数再拆出一个函数。
- 向下规则：函数代码要自顶向下读取让每个函数后面都跟着位于下一抽象层层级的函数，这样在查看函数列表时，就能循抽象层级向下阅读了。
- 使用描述性的函数名称：长而具有描述性的名称，要比短而令人费解的名称好。
- 函数参数：最理想的函数参数是零，其次是一，然后是二，，尽量避免三参数。
- 一元函数：只有一个输入参数算是第二好的做法。（第一是没有参数）
- 二元函数：两个参数函数比一个参数函数难懂，有必要可以利用一些机制将其转换成一元函数。
- 三元函数：函数看起来需要两个，三个或者三个以上说明其中一些参数可以封装成了类了。

## - 3.注释

  注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。作者认为注释是一种失败，我们总无法找到不用注释就能表达自我的方法， 
  所以总要有注释，这并不值得庆贺。写注释的常见动机之一是糟糕代码的存在。带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样的多。
  与其花时间编写解释你搞出的糟糕的代码注释，不如花时间清洁那堆糟糕的代码。
  好注释： 
1.法律信息。
  有时，公司代码规范要求编写与法律有关的注释。例如版权和著作申明。
2.提供信息的注释。 
  不过作者认为 将函数名 重新命名为 responderBeingTested 注释就是多余的。
3.对意图的解释。 
  有时注释不仅提供了有关实现的有用信息，而且还提供了某个决定后面的意图。
4.阐释。 
  有时注释把某种晦涩难明的参数或返回值的意义翻译为某种可读形式。也会是有用的。
  特别是参数或者返回值是某个标准库的一部分，或者你不能修改代码，那帮助阐释其含义的代码就会有用。
  直接看方法可能不明确，但有注释就明白多了。我看这2,3,4都是一个意思。就是说明是干嘛的。
5.警示，
  告诉别人要注意这个方法之类的。
6.放大。
  有的代码可能看着有点多余，但编码者当时是有他自己的考虑，这个时候需要注释下这个代码的重要性。避免后面被优化掉。

## 4.格式

### 纵向格式：

1.函数与函数之间留空行。

2.变量声明：变量声明应该尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现。

3.实体变量 应该在内的顶部，相当于我们的field 字段，会被使用的多。

4.相关函数，如果某个函数调用另外一个，就应该把他们放在一起，而且调用者应该尽可能放在被调用者的上面。这样这个程序就会自然有序。
（之前我喜欢把private的方法 放到一起。当然这确实没有什么实际的意义）

5.“相关概念的代码放在一起。相关性越强，比如一个大功能逻辑靠在一起。” （更多的时候我喜欢用 region 来收起来。）

### 横向格式：

1.一行的长度，作者建议是上限是120个字符

2.赋值语句两端留空。

3.不在函数名和左括号间加空格。因为函数与其参数密切相关。

4.缩进。
  源文件是一种继承结构，而不是一种大纲结构，继承结构中的每一层级都圈出一个范围， 
  也就是代码块，其中有声明语句和执行语句。要体现这种继承结构，就要对源代码进行缩进处理。
  但有时候我们会把if语句，while循环，或小函数写成一行，但这样没有层级的概念，不便阅读，
  还是缩进的好。

## 5.对象和数据结构

1.过程式代码（函数编程）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。反过来讲也说的通,过程式代码难以添加新的数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。所以在设计的时候要分析好是以后是要添加新函数还是要添加新的数据结构。
2.德墨忒尔律：模块不应该了解它所操作对象内部情形。
比如C的方法f只能调用以下对象的方法。
- C
- 由f创建的对象
- 作为参数传递给f的对象
- C的实体变量持有的变量
- varoutpath=cxt.getOptions().getScart().getAbsolutePath();
- 这个代码就违反了上面的德墨忒尔律，调用了返回值的方法。这样就是暴露了内部结构。

## 6.异常处理

  1.try代码就像是事务，catch代码块将程序维持在一种持续状态。在编写可能抛出异常的代码时，最好先写出try-catch-finally 语句。
  2.根据需要定义异常类。对错误分类的方式有多种，可以依据来源，是组件还是其他地方，或者依据类型，是设备错误还是网络错误。不过在我们定义异常类的时候，最重要的考虑是如何捕获它们。
  3.别返回null值。程序中不断的看到检测null值的代码，一处漏掉检测就可能会失控。返回Null，作者认为这种代码很糟糕。建议抛出异常 或者返回特定对象（默认值）。更早的发现问题。同理，也应该避免传递Null值给其他的方法。

## 7.边界

  使用第三方程序包或者开源代码时，要干净利落整合进自己的代码里面。
  1.当第三方程序包发布了新的版本时，可以通过学习性测试来看看程序包的行为有没有发生改变，以及发生了什么改变。
  2.使用尚不存在的代码，有时候我们的第三方，还没有开发好API，但又不能影响到我们的开发进度，所以我们先可以定义好自己想要的接口。如果第三方ok了，我们再对接起来。
  3.通过接口管理第三方边界，可以使用ADApter模式将我的接口转换为第三方提供的接口。这个是要注意，第三方的代码和自己的代码混合太多，这样不便管理。

## 8.单元测试

测试应遵守以下5条规则。
1.快速 测试应该能快速运行，太慢了你就不会频繁的运行，就不会尽早的发现问题。
2.独立。测试应该相互独立，某个测试不应该为下个测试设定条件。当测试相互依赖，一个没通过导致一连串的测试失败，使问题诊断变的困难。
3.可重复。测试应该可以在任何环境中重复通过。
4.自足验证 测试应该有布尔值输出，无论通过或失败，不应该是查看日志文件去确认
5.及时。单元测试应该恰好在使其通过的生产代码之前编写。