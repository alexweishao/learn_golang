## 1.命名

- 名副其实：命名要做到看其名知其意。选择体现本意的名称能让人更容易理解和修改代码。
- 避免误导：避免使用与本意相悖的词，避免使用有歧义的词以及相似的词。
- 使用有意义的命名：a,b,c。a1,a2,a3等均属于无意的词汇。命名要明确用意。
- 使用易读的名称：（正常人在项目中不会出现）
- 使用可搜索的名称：名称长短应与其作用域大小相对应。
- 避免使用编码命名：自找麻烦，增加代码负担，带编码的名称通常发音不便，易打错。
- 类名：类名和对象名应该是名词或者名词短语Customer，AddressParser，不应当是动词。
- 方法名：方法名应当是动词或者动词短语，postPayment/save。
- 一个概念对应一个词：函数名应当独一无二，且要保持一致。
- 使用领域相关的词：只有程序员会读你的代码，尽管使用计算机科学（Computer Science，CS）术语，算法名，模式名，数学术语。

##   2.函数

- 短小：函数的第一规则是要短小。第二规则是更短小。
- 只做一件事：函数应该做一件事。做好这件事。只做这一件事。判断函数是否只做一件事，可以看是否能将目标函数再拆出一个函数。
- 向下规则：函数代码要自顶向下读取让每个函数后面都跟着位于下一抽象层层级的函数，这样在查看函数列表时，就能循抽象层级向下阅读了。
- 使用描述性的函数名称：长而具有描述性的名称，要比短而令人费解的名称好。
- 函数参数：最理想的函数参数是零，其次是一，然后是二，，尽量避免三参数。
- 一元函数：只有一个输入参数算是第二好的做法。（第一是没有参数）
- 二元函数：两个参数函数比一个参数函数难懂，有必要可以利用一些机制将其转换成一元函数。
- 三元函数：函数看起来需要两个，三个或者三个以上说明其中一些参数可以封装成了类了。

## - 3.注释

  注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。作者认为注释是一种失败，我们总无法找到不用注释就能表达自我的方法， 
  所以总要有注释，这并不值得庆贺。写注释的常见动机之一是糟糕代码的存在。带有少量注释的整洁而有表达力的代码，要比带有大量注释的零碎而复杂的代码像样的多。
  与其花时间编写解释你搞出的糟糕的代码注释，不如花时间清洁那堆糟糕的代码。
  好注释： 
1.法律信息。
  有时，公司代码规范要求编写与法律有关的注释。例如版权和著作申明。
2.提供信息的注释。 
  不过作者认为 将函数名 重新命名为 responderBeingTested 注释就是多余的。
3.对意图的解释。 
  有时注释不仅提供了有关实现的有用信息，而且还提供了某个决定后面的意图。
4.阐释。 
  有时注释把某种晦涩难明的参数或返回值的意义翻译为某种可读形式。也会是有用的。
  特别是参数或者返回值是某个标准库的一部分，或者你不能修改代码，那帮助阐释其含义的代码就会有用。
  直接看方法可能不明确，但有注释就明白多了。我看这2,3,4都是一个意思。就是说明是干嘛的。
5.警示，
  告诉别人要注意这个方法之类的。
6.放大。
  有的代码可能看着有点多余，但编码者当时是有他自己的考虑，这个时候需要注释下这个代码的重要性。避免后面被优化掉。

## 4.格式

### 纵向格式：

1.函数与函数之间留空行。

2.变量声明：变量声明应该尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现。

3.实体变量 应该在内的顶部，相当于我们的field 字段，会被使用的多。

4.相关函数，如果某个函数调用另外一个，就应该把他们放在一起，而且调用者应该尽可能放在被调用者的上面。这样这个程序就会自然有序。
（之前我喜欢把private的方法 放到一起。当然这确实没有什么实际的意义）

5.“相关概念的代码放在一起。相关性越强，比如一个大功能逻辑靠在一起。” （更多的时候我喜欢用 region 来收起来。）

### 横向格式：

1.一行的长度，作者建议是上限是120个字符

2.赋值语句两端留空。

3.不在函数名和左括号间加空格。因为函数与其参数密切相关。

4.缩进。
  源文件是一种继承结构，而不是一种大纲结构，继承结构中的每一层级都圈出一个范围， 
  也就是代码块，其中有声明语句和执行语句。要体现这种继承结构，就要对源代码进行缩进处理。
  但有时候我们会把if语句，while循环，或小函数写成一行，但这样没有层级的概念，不便阅读，
  还是缩进的好。

## 5.对象和数据结构

1.过程式代码（函数编程）便于在不改动既有数据结构的前提下添加新函数，面向对象代码便于在不改动既有函数的前提下添加新类。反过来讲也说的通,过程式代码难以添加新的数据结构，因为必须修改所有函数，面向对象代码难以添加新函数，因为必须修改所有类。所以在设计的时候要分析好是以后是要添加新函数还是要添加新的数据结构。
2.德墨忒尔律：模块不应该了解它所操作对象内部情形。
比如C的方法f只能调用以下对象的方法。
- C
- 由f创建的对象
- 作为参数传递给f的对象
- C的实体变量持有的变量
- varoutpath=cxt.getOptions().getScart().getAbsolutePath();
- 这个代码就违反了上面的德墨忒尔律，调用了返回值的方法。这样就是暴露了内部结构。

## 6.异常处理

  1.try代码就像是事务，catch代码块将程序维持在一种持续状态。在编写可能抛出异常的代码时，最好先写出try-catch-finally 语句。
  2.根据需要定义异常类。对错误分类的方式有多种，可以依据来源，是组件还是其他地方，或者依据类型，是设备错误还是网络错误。不过在我们定义异常类的时候，最重要的考虑是如何捕获它们。
  3.别返回null值。程序中不断的看到检测null值的代码，一处漏掉检测就可能会失控。返回Null，作者认为这种代码很糟糕。建议抛出异常 或者返回特定对象（默认值）。更早的发现问题。同理，也应该避免传递Null值给其他的方法。

## 7.边界

  使用第三方程序包或者开源代码时，要干净利落整合进自己的代码里面。
  1.当第三方程序包发布了新的版本时，可以通过学习性测试来看看程序包的行为有没有发生改变，以及发生了什么改变。
  2.使用尚不存在的代码，有时候我们的第三方，还没有开发好API，但又不能影响到我们的开发进度，所以我们先可以定义好自己想要的接口。如果第三方ok了，我们再对接起来。
  3.通过接口管理第三方边界，可以使用ADApter模式将我的接口转换为第三方提供的接口。这个是要注意，第三方的代码和自己的代码混合太多，这样不便管理。

## 8.单元测试

测试应遵守以下5条规则。
1.快速 测试应该能快速运行，太慢了你就不会频繁的运行，就不会尽早的发现问题。
2.独立。测试应该相互独立，某个测试不应该为下个测试设定条件。当测试相互依赖，一个没通过导致一连串的测试失败，使问题诊断变的困难。
3.可重复。测试应该可以在任何环境中重复通过。
4.自足验证 测试应该有布尔值输出，无论通过或失败，不应该是查看日志文件去确认
5.及时。单元测试应该恰好在使其通过的生产代码之前编写。

## 9.类

1.类应该短小，通过采用不同的衡量方法计算权责。
2.单一权责原则认为：类或者模块有且只有一条加以修改的理由。
每个达到一定规模的系统都会包括大量逻辑和复杂性。管理这种复杂性的首要目标就是加以组织，以便开发者在哪儿能找到东西，反之，拥有巨大、多目的的类的系统，总是让我们在目前并不需要了解的一大堆东西中艰难的跋涉。
3.系统应该有许多短小的类而不是少量巨大的类组成。
4.内聚：类应该只有少量实体变量。类中的每个方法都应该操作一个或多个  这种变量。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。内聚性高，意味着类中的方法和变量相互依赖，相互结合成一个逻辑整体。
5.为了修改而组织：在整洁系统中，对类加以组织，以降低修改的风险。
开放闭合原则：类应当对阔i展开放，对修改封闭。
通过接口和抽象类型来隔离这些细节带来的影响。

## 10.系统

1.将系统的构造和使用分开，因为构造和使用是不一样过程。
2.工厂：应用程序需要确定什么时候创建对象，于是可以使用抽象工厂模式。将构造的细节葛丽鱼应用程序之外。
3.依赖注入：通过一块来诸如可以实现分离构造与使用。在以来管理情景中，对象不应该负责实例化对自己自身的依赖，反之，应该将这份权责移交给其他有权利的机制，从而实现控制的反转。
4.扩容：系统不是一开始就能实现，通过用户的需求来逐渐构造系统。然后再重构，在扩容系统，实现新用户的需求。这就是迭代和增量敏捷的精髓所在。就像城市不断地拆除与重建。
5.优化决策：模块化和关注面切分成就了分散化管理和决策。在庞大的系统中，不管是一座城市还是一个软件项目，无人做到所有的决策。最好的授权给最有资格的人。延迟决策至最后一刻也是好手段。

## 11.迭进

1.简单设计规则
（1）运行所有测试：编写测试越多，就会越遵循DIP之类的原则，使用依赖注入，接口和抽象等工具尽可能减少耦合
（2）-（4）重构：在重构过程中，可以应用有关优秀软件设计的一切知识，提升内聚性，降低耦合度。换句话说：消除重复，保证表达力，尽可能的减少类和方法的数量。
2.不可重复：重复是良好设计系统的大敌。它代表着额外的工作、额外的风险和额外不必要的复杂度。重复有多种表现。雷同的代码行是一种。

## 12.并发编程

1.为什么要并发：并发是一种解耦策略，它帮助我们把做什么(目的)和何时（时机）做分解开。在单线程应用中，目的与时机紧密耦合，很多时候只要查看堆栈追踪即可断定应用程序的状态。
2.并发编程的迷思与误解：
（1）并发总能改进性能：并发有时能改进性能，但是只是在多个线程或处理器之间能大量分享等待时间的时候管用。事情没那么简单。
（2）编写并发编程无需修改设计：事实上，并发算法的设计有可能与单线程系统的设计极为不相同。目的与时机的解耦往往对系统结构产生巨大影响。
（3）在web或者ejb容器的时候理解并发问题并不重要。
编写并发软件的比较中肯说法如下：
- 并发会在性能和编写额外代码上增加一些开销。
- 正确的并发是复杂的，即使对于简单的问题也是如此。
- 并发缺陷并非总能重现，所以常被看做偶发事件而忽略，而未被当做真的缺陷看待。
- 并发常常需要对设计策略的根本性修改。
  在并发编程中用到的几种执行模型。
  1）生产者-消费者模型
  一个或多个生产者线程创建某些工作，并置于缓存或者队列中。一个或者多个消费者线程从队列中获取并完成这些工作。生产者和消费者之间的队列是一种限定资源。
  2）读者-作者模型。
  当存在一个主要为读者线程提供信息源，但只是偶尔被作者线程更新的共享资源，吞吐量就会是个问题。增加吞吐量，会导致线程饥饿和过时信息的积累。协调读者线程不去读取正在更新的信息，而作者线程倾向于长期锁定读者线程。
  3）宴席哲学家。
  许多企业级应用中会存在进程竞争资源的情形，如果没有用心设计，这种竞争会遭遇死锁，活锁，吞吐量和效率低等问题。

## 最后一章 17 
一代码整洁的一些内容